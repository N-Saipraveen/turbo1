import { toPng, toSvg } from 'html-to-image';
import { UnifiedSchema } from './schemaParser';

/**
 * Export diagram as PNG
 */
export async function exportToPng(_elementId: string, filename: string = 'diagram.png'): Promise<void> {
  const element = document.querySelector(`.react-flow`) as HTMLElement;
  if (!element) {
    throw new Error('Diagram element not found');
  }

  try {
    const dataUrl = await toPng(element, {
      backgroundColor: '#ffffff',
      quality: 1.0,
      pixelRatio: 2,
    });

    const link = document.createElement('a');
    link.download = filename;
    link.href = dataUrl;
    link.click();
  } catch (error) {
    throw new Error(`Failed to export PNG: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Export diagram as SVG
 */
export async function exportToSvg(_elementId: string, filename: string = 'diagram.svg'): Promise<void> {
  const element = document.querySelector(`.react-flow`) as HTMLElement;
  if (!element) {
    throw new Error('Diagram element not found');
  }

  try {
    const dataUrl = await toSvg(element, {
      backgroundColor: '#ffffff',
    });

    const link = document.createElement('a');
    link.download = filename;
    link.href = dataUrl;
    link.click();
  } catch (error) {
    throw new Error(`Failed to export SVG: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Generate DBML from unified schema
 */
export function generateDbml(schema: UnifiedSchema): string {
  let dbml = '// Generated by TurboDbx\n\n';

  // Generate table definitions
  for (const table of schema.tables) {
    dbml += `Table ${table.name} {\n`;

    for (const column of table.columns) {
      let line = `  ${column.name} ${column.type}`;

      const attributes: string[] = [];
      if (column.isPrimaryKey) attributes.push('pk');
      if (column.isUnique) attributes.push('unique');
      if (!column.isNullable) attributes.push('not null');

      if (attributes.length > 0) {
        line += ` [${attributes.join(', ')}]`;
      }

      dbml += line + '\n';
    }

    // Add indexes
    if (table.indexes && table.indexes.length > 0) {
      dbml += '\n';
      for (const index of table.indexes) {
        dbml += `  indexes {\n`;
        dbml += `    (${index.columns.join(', ')})\n`;
        dbml += `  }\n`;
      }
    }

    dbml += '}\n\n';
  }

  // Generate relationships
  if (schema.relationships.length > 0) {
    dbml += '// Relationships\n';
    for (const rel of schema.relationships) {
      const relType = rel.type === 'one-to-one' ? '-' : rel.type === 'one-to-many' ? '<' : '<>';
      dbml += `Ref: ${rel.fromTable}.${rel.fromColumn} ${relType} ${rel.toTable}.${rel.toColumn}\n`;
    }
  }

  return dbml;
}

/**
 * Download DBML file
 */
export function downloadDbml(schema: UnifiedSchema, filename: string = 'schema.dbml'): void {
  const dbml = generateDbml(schema);
  const blob = new Blob([dbml], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);

  const link = document.createElement('a');
  link.download = filename;
  link.href = url;
  link.click();

  URL.revokeObjectURL(url);
}

/**
 * Download schema as JSON
 */
export function downloadSchemaJson(schema: UnifiedSchema, filename: string = 'schema.json'): void {
  const json = JSON.stringify(schema, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);

  const link = document.createElement('a');
  link.download = filename;
  link.href = url;
  link.click();

  URL.revokeObjectURL(url);
}

/**
 * Copy text to clipboard
 */
export async function copyToClipboard(text: string): Promise<void> {
  try {
    await navigator.clipboard.writeText(text);
  } catch (error) {
    // Fallback for older browsers
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-9999px';
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
  }
}
